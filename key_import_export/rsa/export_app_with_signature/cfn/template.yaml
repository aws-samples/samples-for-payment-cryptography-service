AWSTemplateFormatVersion: '2010-09-09'
Description: Automation for assisting with exchanging keys with trusted business partners

Parameters:
  COMMONNAME:
    Description: Common Name
    Type: String
    Default: example.com
  COUNTRYNAME:
    Description: Country Name
    Type: String
    Default: US
  LOCALITYNAME:
    Description: Locality Name
    Type: String
    Default: San Fransisco
  ORGANIZATIONNAME:
    Description: Organization Name
    Type: String
    Default: Example Organization
  STATEORPROVINCENAME:
    Description: State or Province
    Type: String
    Default: California
  Environment:
    Description: The environment for the key exchange process (non-production or production). This value is used to determine which UIDs should be verified in the leaf certificate. Your business partner should provide information about which environment value to use.
    Type: String
    AllowedValues:
      - non-production
      - production
    Default: non-production
  DataType:
    Description: The data type for the key exchange process (cardholder or pin). This value is used to determine which UIDs should be verified in the leaf certificate. Your business partner should provide information about which data type value to use.
    Type: String
    AllowedValues:
      - cardholder
      - pin
    Default: cardholder
  CertificateS3URI:
    Description: The S3 URI for the leaf certificate (transport key) provided by your business partner (e.g., s3://bucket-name/path/to/certificate.pem). This should be the location where you uploaded the leaf certificate / end-entity certificate provided by your business partner. The PspKEKExchangeLambda will extract the public key from this certificate, and use it to wrap the KEK.
    Type: String
    Default: ''
  RootCertificateS3URI:
    Description: The S3 URI for the root certificate associated with the transport key (e.g., s3://bucket-name/path/to/root-certificate.pem). The PspKEKExchangeLambda will import this certificate to AWS Payment Cryptography, as this is required to wrap and export the KEK using the transport key.
    Type: String
    Default: ''
  ICACertificateS3URI:
    Description: The S3 URI for the intermediate or issuing CA certificate associated with the transport key (e.g., s3://bucket-name/path/to/ica-certificate.pem). The PspKEKExchangeLambda will import this certificate to AWS Payment Cryptography, as this is required to wrap and export the KEK using the transport key.
    Type: String
    Default: ''
  APCRootKeyARN:
    Description: The ARN of a root certificate that you have previously imported to AWS Payment Cryptography. Use this parameter if you have already imported the Root CA certificate into APC. If this value is empty, the PspKEKExchangeLambda will import the certificate using the value specified in the RootCertificateS3URI parameter.
    Type: String
    Default: ''
  APCICAKeyARN:
    Description: The ARN of a intermediate or issuing certificate that you have previously imported to AWS Payment Cryptography. Use this parameter if you have already imported the ICA certificate into APC. If this value is empty, the PspKEKExchangeLambda will import the certificate using the value specified in the ICACertificateS3URI parameter.
    Type: String
    Default: ''
  APCKeyARN:
    Description: The ARN of the KEK you want to securely export and exchange with your trusted business partner. Use this parameter if you have already generated or imported your KEK in AWS Payment Cryptography. If this value is empty, the PspKEKExchangeLambda will generate a new AES128 KEK in AWS Payment Cryptography on your behalf.
    Type: String
    Default: ''


Resources:
  
  # Log Policy for Lambdas
  LogsPolicy:
    Type: "AWS::IAM::ManagedPolicy"
    Properties:
      Path: /
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: 'Allow'
            Action:
              - 'logs:CreateLogGroup'
              - 'logs:CreateLogStream'
              - 'logs:PutLogEvents'
            Resource: '*'

  # Create RSA 2048 asymmetric KMS key for signing
  CSRKMSKey:
    Type: 'AWS::KMS::Key'
    Properties:
      Description: RSA_2048 asymmetric KMS key for signing and verification
      KeySpec: RSA_2048
      KeyUsage: SIGN_VERIFY
      KeyPolicy:
        Version: 2012-10-17
        Id: key-default-1
        Statement:
        - Sid: Enable IAM User Permissions for root
          Effect: Allow
          Principal:
            AWS: !Sub 'arn:aws:iam::${AWS::AccountId}:root'
          Action: 'kms:*'
          Resource: '*'
        - Sid: Allow CSRBuilderLambda to access the key
          Effect: Allow
          Principal:
            AWS: !GetAtt CSRBuilderCustomResourceRole.Arn
          Action:
            - 'kms:GetPublicKey'
            - 'kms:DescribeKey'
            - 'kms:Sign'
          Resource: '*'
        - Sid: Allow PspKEKexchange Lambda to access the key
          Effect: Allow
          Principal:
            AWS: !GetAtt PspKEKexchangeRole.Arn
          Action:
            - 'kms:GetPublicKey'
            - 'kms:DescribeKey'
            - 'kms:Sign'
          Resource: '*'

  # S3 Bucket to store the results
  ResultsBucket:
    Type: AWS::S3::Bucket
    Properties:
      VersioningConfiguration:
        Status: Enabled
      LoggingConfiguration:
        DestinationBucketName: !Ref LoggingBucket
        LogFilePrefix: access-logs
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
        - Key: Name
          Value: Results-Bucket
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256

  ResultsBucketPolicy:
    Type: 'AWS::S3::BucketPolicy'
    Properties:
      Bucket: !Ref ResultsBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action:
              - 's3:*'
            Effect: Deny
            Resource: 
              - !Sub arn:aws:s3:::${ResultsBucket}/*
              - !Sub arn:aws:s3:::${ResultsBucket}
            Principal: "*"
            Condition:
              Bool:
                'aws:SecureTransport': 'false'

  # S3 Bucket to store the access logs for the ResultsBucket
  LoggingBucket: 
    Type: "AWS::S3::Bucket"
    Properties:
      VersioningConfiguration:
        Status: Enabled
      OwnershipControls:
        Rules:
          - ObjectOwnership: BucketOwnerPreferred
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true

  LoggingBucketPolicy:
    Type: 'AWS::S3::BucketPolicy'
    Properties:
      Bucket: !Ref LoggingBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action:
              - 's3:PutObject'
            Effect: Allow
            Principal:
              Service: logging.s3.amazonaws.com
            Resource: 
              - !Sub arn:aws:s3:::${LoggingBucket}/*
          - Action:
              - 's3:*'
            Effect: Deny
            Resource: 
              - !Sub arn:aws:s3:::${LoggingBucket}/*
              - !Sub arn:aws:s3:::${LoggingBucket}
            Principal: "*"
            Condition:
              Bool:
                'aws:SecureTransport': 'false'

   # For building Lambda layer
  BuildRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: 'Allow'
            Principal:
              Service:
                - 'codebuild.amazonaws.com'
            Action:
              - 'sts:AssumeRole'
      ManagedPolicyArns:
        - !GetAtt LogsPolicy.PolicyArn
      Policies:
        - PolicyName: 'LambdaLayerPolicy'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: 'Allow'
                Action:
                  - 'lambda:PublishLayerVersion'
                Resource: '*'
   # For building Lambda layer
  BuildProject:
    Type: AWS::CodeBuild::Project
    Properties:
      Source:
        Type: GITHUB
        Location: https://github.com/aws-samples/samples-for-payment-cryptography-service.git
        BuildSpec: !Sub |
          version: 0.2
          phases:
            pre_build:
              commands:
                - pip3 install awscli --upgrade --user
            build:
              commands:
                - cd key-import-export/rsa/export_app_with_signature
                - chmod +x ./buildlayer.sh 
                - ./buildlayer.sh cryptography-layer python3.11 requirements.txt
            post_build:
              commands:
                - pwd
      Environment:
        Type: LINUX_CONTAINER
        Image: aws/codebuild/amazonlinux2-x86_64-standard:5.0
        ComputeType: BUILD_GENERAL1_SMALL
      ServiceRole: !GetAtt BuildRole.Arn
      Artifacts:
        Type: NO_ARTIFACTS

### Custom Resources ###

  # For building Lambda layer
  BuildCustomResourceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: 'Allow'
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Path: "/"
      ManagedPolicyArns:
        - !GetAtt LogsPolicy.PolicyArn
      Policies:
        - PolicyName: BuildPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - codebuild:StartBuild
                  - codebuild:BatchGetBuilds
                Resource:
                  - '*'
   # For building Lambda layer
  BuildCustomResourceFunction:
    Type: "AWS::Lambda::Function"
    Properties:
      Handler: index.handler
      Role: !GetAtt BuildCustomResourceRole.Arn
      Timeout: 900
      Runtime: python3.12
      Code:
        ZipFile: !Sub |
          import boto3
          from time import sleep
          import cfnresponse

          def handler(event, context):

            request_type = event['RequestType']
            print(request_type)

            if request_type in ['Create', 'Update']:
              client = boto3.client("codebuild")

              build_id = client.start_build(
                projectName=event['ResourceProperties']['PROJECT']
              )['build']['id']
              status = 'STARTING'

              while status != 'SUCCEEDED':
                if status in ['FAILED', 'FAULT', 'TIMED_OUT', 'STOPPED']:
                  cfnresponse.send(event, context, cfnresponse.FAILED, {})
                  return
                sleep(15)
                status = client.batch_get_builds(ids=[build_id])['builds'][0]['buildStatus']
                print(status)

            elif request_type == 'Delete':
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {})

            cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
   # For building Lambda layer
  BuildCustomResource:
    Type: Custom::BuildCode
    Properties:
      ServiceToken: !GetAtt BuildCustomResourceFunction.Arn
      PROJECT: !Ref BuildProject

  # IAM Role for KMS CSR Builder Lambda function
  CSRBuilderCustomResourceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: 'Allow'
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Path: "/"
      ManagedPolicyArns:
        - !GetAtt LogsPolicy.PolicyArn
      Policies:
        - PolicyName: KMSPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'kms:GetPublicKey'
                  - 'kms:DescribeKey'
                  - 'kms:Sign'
                Resource:
                  - '*'
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 's3:GetObject'
                Resource: '*'
              - Effect: Allow
                Action:
                  - 's3:PutObject'
                Resource:
                  - !Sub arn:aws:s3:::${ResultsBucket}/*

  # Lambda function to build KMS CSR
  CSRBuilderLambda:
    Type: "AWS::Lambda::Function"
    DependsOn:
      - CSRKMSKey
      - BuildCustomResource
      - BuildProject
    Properties:
      Description: "CSRBuilder Lambda"
      Handler: "index.lambda_handler"
      Architectures: 
        - "x86_64"
      Code:
        ZipFile: |
          import boto3
          from asn1crypto import x509, csr, pem, algos
          from oscrypto import asymmetric
          import inspect
          import os
          import re
          import sys
          import textwrap
          import json
          import traceback
          import cfnresponse

          kms = boto3.client('kms')
          s3_client = boto3.client('s3')

          def lambda_handler(event, context):
              try:
                  # Extract parameters from the event properties
                  request_type = event['RequestType']

                  if request_type == 'Create':
                      COUNTRY_NAME = event['ResourceProperties']['COUNTRY_NAME']
                      COMMON_NAME = event['ResourceProperties']['COMMON_NAME']
                      LOCALITY_NAME = event['ResourceProperties']['LOCALITY_NAME']
                      ORGANIZATION_NAME = event['ResourceProperties']['ORGANIZATION_NAME']
                      STATE_OR_PROVINCE_NAME = event['ResourceProperties']['STATE_OR_PROVINCE_NAME']
                      KMS_ARN = event['ResourceProperties']['KMS_ARN']
                      RESULTS_BUCKET = event['ResourceProperties']['RESULTS_BUCKET']

                      subject_dict = {
                          "country_name": COUNTRY_NAME,
                          "state_or_province_name": STATE_OR_PROVINCE_NAME,
                          "locality_name": LOCALITY_NAME,
                          "organization_name": ORGANIZATION_NAME,
                          "common_name": COMMON_NAME
                      }

                      subject = x509.Name.build(subject_dict)

                      # Create KMSCSRBuilder instance
                      csr_builder = KMSCSRBuilder(subject, KMS_ARN)

                      # Build the CSR
                      certification_request = csr_builder.build_with_kms(KMS_ARN)

                      # PEM encode the CSR
                      pem_csr = pem_armor_csr(certification_request)

                      # Convert byte string to regular string
                      pem_csr_str = pem_csr.decode('utf-8')

                      # Write the CSR to the S3 bucket
                      s3_client.put_object(Bucket=RESULTS_BUCKET, Key='results/csr.pem', Body=pem_csr_str)

                      # Return a success response without a physical resource ID
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, "CSR written to S3")

                  elif request_type == 'Delete':
                      # No action needed for deletion
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, "Resource deletion successful")

              except ValueError as ve:
                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, str(ve))
              except boto3.exceptions.Boto3Error as be:
                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, str(be))
              except Exception as e:
                  # Log the full error for debugging
                  print(f"Unexpected error: {str(e)}")
                  print(traceback.format_exc())

                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, 'An unexpected error occurred')

          def _writer(func):
              """
              Decorator for a custom writer, but a default reader
              """
              name = func.__name__
              return property(fget=lambda self: getattr(self, '_%s' % name), fset=func)

          def pem_armor_csr(certification_request):
              """
              Encodes a CSR into PEM format
              """
              if not isinstance(certification_request, csr.CertificationRequest):
                  raise TypeError(_pretty_message(
                      '''
                      certification_request must be an instance of
                      asn1crypto.csr.CertificationRequest, not %s
                      ''',
                      _type_name(certification_request)
                  ))

              return pem.armor(
                  'CERTIFICATE REQUEST',
                  certification_request.dump()
              )

          class KMSCSRBuilder(object):
              _subject = None
              _KMS_ARN = None
              _hash_algo = None
              _basic_constraints = None
              _subject_alt_name = None
              _key_usage = None
              _extended_key_usage = None
              _other_extensions = None
              _kms_signature_algo = None

              _special_extensions = set([
                  'basic_constraints',
                  'subject_alt_name',
                  'key_usage',
                  'extended_key_usage',
              ])

              def __init__(self, subject, KMS_ARN):
                  self.subject = subject
                  self.KMS_ARN = KMS_ARN
                  self.ca = False

                  self._hash_algo = 'sha256'
                  self._other_extensions = {}
                  self._kms_signature_algo = 'RSASSA_PKCS1_V1_5_SHA_256'

              @_writer
              def subject(self, value):
                  if not isinstance(value, x509.Name) and not isinstance(value, dict):
                      raise TypeError(_pretty_message(
                          '''
                          subject must be an instance of asn1crypto.x509.Name or a dict,
                          not %s
                          ''',
                          _type_name(value)
                      ))

                  if isinstance(value, dict):
                      value = x509.Name.build(value)

                  self._subject = value

              @_writer
              def KMS_ARN(self, value):
                  try:
                      PKresponse = kms.get_public_key(KeyId=value)
                  except:
                      print("Could not get PublicKey")

                  if not PKresponse['KeyUsage'] == "SIGN_VERIFY":
                      raise ValueError("KMS_ARN must be an ARN for a KMS Key with SIGN_VERIFY")
                  
                  rawPublicKey = PKresponse['PublicKey']
                  definedPubKey = asymmetric.load_public_key(rawPublicKey)
                  self._subject_public_key = definedPubKey.asn1
                  self._KMS_ARN = value

              @_writer
              def hash_algo(self, value):
                  if value not in set(['sha1', 'sha256', 'sha512']):
                      raise ValueError(_pretty_message(
                          '''
                          hash_algo must be one of "sha1", "sha256", "sha512", not %s
                          ''',
                          repr(value)
                      ))
                  self._hash_algo = value

              @_writer
              def kms_signature_algo(self, value):
                  valid_algos = [
                      'RSASSA_PSS_SHA_256', 
                      'RSASSA_PSS_SHA_384', 
                      'RSASSA_PSS_SHA_512',
                      'RSASSA_PKCS1_V1_5_SHA_256',
                      'RSASSA_PKCS1_V1_5_SHA_384',
                      'RSASSA_PKCS1_V1_5_SHA_512',
                      'ECDSA_SHA_256',
                      'ECDSA_SHA_384',
                      'ECDSA_SHA_512'
                  ]

                  if value not in valid_algos:
                      raise ValueError(_pretty_message(
                          '''
                          kms_signature_algo must be supported by AWS KMS, not %s
                          ''',
                          repr(value)
                      ))
                  self._hash_algo = 'sha' + value[-3:]
                  self._kms_signature_algo = value

              def build_with_kms(self, KMS_ARN):
                  kms_algos = kms.describe_key(KeyId=KMS_ARN)['KeyMetadata']['SigningAlgorithms']
                  if "RSASSA_PSS_SHA_256" in kms_algos:
                      signature_algo = 'rsa'
                  elif "ECDSA_SHA_256" in kms_algos:
                      signature_algo = 'ecdsa'
                  
                  if "ecdsa" in signature_algo:
                      signature_algorithm_id = {
                          'algorithm': '%s_%s' % (self._hash_algo, signature_algo)
                      }
                      self.kms_signature_algo = '%s_%s' % ("ECDSA_SHA", self._hash_algo[-3:])
                  elif "rsa" in signature_algo:
                      if "PSS" in self._kms_signature_algo:
                          signature_algorithm_id = algos.SignedDigestAlgorithm({
                              'algorithm': 'rsassa_pss',
                              'parameters': algos.RSASSAPSSParams({
                                  'hash_algorithm': algos.DigestAlgorithm({
                                      'algorithm': self._hash_algo
                                  }),
                                  'mask_gen_algorithm': algos.MaskGenAlgorithm({
                                      'algorithm': 'mgf1',
                                      'parameters': algos.DigestAlgorithm({
                                          'algorithm': self._hash_algo
                                      }),
                                  }),
                                  'salt_length': int(self._hash_algo[-3:])//8
                              })   
                          })
                          self.kms_signature_algo = '%s_%s' % ("RSASSA_PSS_SHA", self._hash_algo[-3:])
                      else:   
                          signature_algorithm_id = {
                              'algorithm': '%s_%s' % (self._hash_algo, signature_algo)
                          }
                          self.kms_signature_algo = '%s_%s' % ("RSASSA_PKCS1_V1_5_SHA", self._hash_algo[-3:])

                  def _make_extension(name, value):
                      return {
                          'extn_id': name,
                          'critical': self._determine_critical(name),
                          'extn_value': value
                      }

                  extensions = []
                  for name in sorted(self._special_extensions):
                      value = getattr(self, '_%s' % name)
                      if value is not None:
                          extensions.append(_make_extension(name, value))

                  for name in sorted(self._other_extensions.keys()):
                      extensions.append(_make_extension(name, self._other_extensions[name]))

                  attributes = []
                  if extensions:
                      attributes.append({
                          'type': 'extension_request',
                          'values': [extensions]
                      })

                  certification_request_info = csr.CertificationRequestInfo({
                      'version': 'v1',
                      'subject': self._subject,
                      'subject_pk_info': self._subject_public_key,
                      'attributes': attributes
                  })

                  signature = kms.sign(KeyId=KMS_ARN, SigningAlgorithm=self._kms_signature_algo, Message=certification_request_info.dump())['Signature']
                  return csr.CertificationRequest({
                      'certification_request_info': certification_request_info,
                      'signature_algorithm': signature_algorithm_id,
                      'signature': signature
                  })

              def _determine_critical(self, name):
                  if name == 'subject_alt_name':
                      return len(self._subject) == 0

                  if name == 'basic_constraints':
                      return self.ca is True

                  return {
                      'subject_directory_attributes': False,
                      'key_usage': True,
                      'issuer_alt_name': False,
                      'name_constraints': True,
                      'certificate_policies': False,
                      'policy_mappings': True,
                      'policy_constraints': True,
                      'extended_key_usage': False,
                      'inhibit_any_policy': True,
                      'subject_information_access': False,
                      'tls_feature': False,
                      'ocsp_no_check': False,
                  }.get(name, False)

          def _pretty_message(string, *params):
              """
              Takes a multi-line string and does the following:

              - dedents
              - converts newlines with text before and after into a single line
              - strips leading and trailing whitespace
              """
              output = textwrap.dedent(string)

              if output.find('\n') != -1:
                  output = re.sub('(?<=\\S)\n(?=[^ \n\t\\d\\*\\-=])', ' ', output)

              if params:
                  output = output % params

              output = output.strip()

              return output

          def _type_name(value):
              """
              :param value:
                  A value to get the object name of

              :return:
                  A unicode string of the object name
              """
              if inspect.isclass(value):
                  cls = value
              else:
                  cls = value.__class__
              if cls.__module__ in set(['builtins', '__builtin__']):
                  return cls.__name__
              return '%s.%s' % (cls.__module__, cls.__name__)
      MemorySize: 128
      Role: !GetAtt CSRBuilderCustomResourceRole.Arn
      Runtime: "python3.11"
      Timeout: 30
      EphemeralStorage: 
        Size: 512
      Layers: 
        - !Sub "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:layer:cryptography-layer:1"

  # KMS CSR Builder Custom Resource
  CSRBuilderCustomResource:
    Type: Custom::BuildCSR
    DependsOn:
      - BuildCustomResource
      - CSRBuilderLambda
      - BuildProject
    Properties:
      ServiceToken: !GetAtt CSRBuilderLambda.Arn
      COMMON_NAME: !Ref COMMONNAME
      COUNTRY_NAME: !Ref COUNTRYNAME
      KMS_ARN: !GetAtt CSRKMSKey.Arn
      LOCALITY_NAME: !Ref LOCALITYNAME
      ORGANIZATION_NAME: !Ref ORGANIZATIONNAME
      STATE_OR_PROVINCE_NAME: !Ref STATEORPROVINCENAME
      RESULTS_BUCKET: !Ref ResultsBucket


  # For building Lambda layer
  PspKEKexchangeRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: 'Allow'
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Path: "/"
      ManagedPolicyArns:
        - !GetAtt LogsPolicy.PolicyArn
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 's3:GetObject'
                Resource: '*'
              - Effect: Allow
                Action:
                  - 's3:PutObject'
                Resource:
                  - !Sub arn:aws:s3:::${ResultsBucket}/*
        - PolicyName: APCAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'payment-cryptography:GetKey'
                  - 'payment-cryptography:ImportKey'
                  - 'payment-cryptography:CreateKey'
                  - 'payment-cryptography:ExportKey'
                  - 'payment-cryptography:TagResource'
                Resource: '*'
        - PolicyName: KMSPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'kms:GetPublicKey'
                  - 'kms:DescribeKey'
                  - 'kms:Sign'
                Resource:
                  - '*'
  
  # Lambda function to build KMS CSR
  PspKEKexchangeLambda:
    Type: "AWS::Lambda::Function"
    DependsOn:
      - CSRKMSKey
      - BuildCustomResource
      - BuildProject
    Properties:
      Description: "PSP KEK Exchange Lambda"
      Handler: "index.lambda_handler"
      Architectures: 
        - "x86_64"
      Code:
        ZipFile: |
          import sys
          import json
          import base64
          from datetime import datetime
          import boto3
          import requests
          import os
          import traceback
          from urllib.parse import urlparse
          from cryptography import x509
          from cryptography.hazmat.backends import default_backend
          from cryptography.hazmat.primitives import serialization, hashes
          from cryptography.hazmat.primitives.asymmetric import rsa
          from cryptography.x509.oid import NameOID, ExtensionOID
          from cryptography.x509 import ocsp
          from botocore.exceptions import ClientError
          from cryptography.hazmat.primitives.asymmetric import padding
          from cryptography.hazmat.primitives.asymmetric import utils as asymmetric_utils

          def lambda_handler(event, context):
              try:

                  # Get environment variables
                  CERTIFICATE_S3_URI = os.environ.get('CERTIFICATE_S3_URI')
                  ROOT_CERTIFICATE_S3_URI = os.environ.get('ROOT_CERTIFICATE_S3_URI')
                  ICA_CERTIFICATE_S3_URI = os.environ.get('ICA_CERTIFICATE_S3_URI')
                  DATA_TYPE = os.environ.get('DATA_TYPE')
                  ENVIRONMENT = os.environ.get('ENVIRONMENT')
                  KMS_KEY_ARN = os.environ.get('KMS_KEY_ARN')
                  APC_KEY_ARN = os.environ.get('APC_KEY_ARN')
                  APC_ROOT_KEY_ARN = os.environ.get('APC_ROOT_KEY_ARN')
                  APC_ICA_KEY_ARN = os.environ.get('APC_ICA_KEY_ARN')
                  S3_PREFIX = 'results/'
                  S3_BUCKET = os.environ.get('S3_BUCKET')
                  s3_client = boto3.client('s3')

                  
                  if not CERTIFICATE_S3_URI:
                      print("Error: CERTIFICATE_S3_URI environment variable is not set")
                      raise ValueError("CERTIFICATE_S3_URI is missing")

                  parsed_uri = urlparse(CERTIFICATE_S3_URI)
                  s3_bucket_name = parsed_uri.netloc
                  s3_file_key = parsed_uri.path.lstrip('/')

                  tmp_file_path = f"/tmp/{os.path.basename(s3_file_key)}"

                  try:
                      s3_client.download_file(s3_bucket_name, s3_file_key, tmp_file_path)
                  except ClientError as e:
                      print(f"Error downloading file from S3: {e}")
                      raise

                  with open(tmp_file_path, 'rb') as certificate_pem:
                      cert_contents = certificate_pem.read()
                      cert = x509.load_pem_x509_certificate(cert_contents)

                  if ROOT_CERTIFICATE_S3_URI is None and APC_ROOT_KEY_ARN is None:
                      print("Error: Neither ROOT_CERTIFICATE_S3_URI nor APC_ROOT_KEY_ARN environment variable is set")
                      raise ValueError("Either ROOT_CERTIFICATE_S3_URI or APC_ROOT_KEY_ARN must be provided")

                  if ROOT_CERTIFICATE_S3_URI:
                      parsed_uri_root = urlparse(ROOT_CERTIFICATE_S3_URI)
                      s3_bucket_name_root = parsed_uri_root.netloc
                      s3_file_key_root = parsed_uri_root.path.lstrip('/')

                      tmp_file_path_root = f"/tmp/{os.path.basename(s3_file_key_root)}"
                      #print("ROOT INFO Bucket:",s3_bucket_name_root,"File Key Root",s3_file_key_root,"Tmp Location",tmp_file_path_root)

                      try:
                          s3_client.download_file(s3_bucket_name_root, s3_file_key_root, tmp_file_path_root)
                      except ClientError as e:
                          print(f"Error downloading file from S3: {e}")
                          raise

                      with open(tmp_file_path_root, 'rb') as cert_file:
                          root_cert_contents = cert_file.read()
                          root_cert = x509.load_pem_x509_certificate(root_cert_contents, default_backend())

                  if not ICA_CERTIFICATE_S3_URI and not APC_ICA_KEY_ARN:
                      print("Error: Neither ICA_CERTIFICATE_S3_URI nor APC_ICA_KEY_ARN environment variable is set")
                      raise ValueError("Either ICA_CERTIFICATE_S3_URI or APC_ICA_KEY_ARN must be provided")

                  if ICA_CERTIFICATE_S3_URI:
                      parsed_uri_ica = urlparse(ICA_CERTIFICATE_S3_URI)
                      s3_bucket_name_ica = parsed_uri_ica.netloc
                      s3_file_key_ica = parsed_uri_ica.path.lstrip('/')

                      tmp_file_path_ica = f"/tmp/{os.path.basename(s3_file_key_ica)}"

                      try:
                          s3_client.download_file(s3_bucket_name_ica, s3_file_key_ica, tmp_file_path_ica)
                      except ClientError as e:
                          print(f"Error downloading file from S3: {e}")
                          raise

                      with open(tmp_file_path_ica, 'rb') as ica_certificate_pem:
                          ica_cert = ica_certificate_pem.read()
                  
                  # Check if Root Cert ARN & ICA Cert ARN are present, if not, import them
                  if not APC_ROOT_KEY_ARN:
                      APC_ROOT_KEY_ARN, APC_ICA_KEY_ARN  = import_public_key_to_payment_crypto(root_cert, ica_cert)
                  else:
                      print("Root Key ARN already found:", APC_ROOT_KEY_ARN)

                  # Check if APC Key ARN is present, if not, create a new one
                  if not APC_KEY_ARN:
                      APC_KEY_ARN, kcv = generate_aes_128_key()
                  else:
                      kcv = get_key_check_value(APC_KEY_ARN)
                  
                  # Check if KMS key ARN is present, if not, create a new one
                  if not KMS_KEY_ARN:
                      KMS_KEY_ARN = generate_rsa_key_pair_in_kms()
                  
                  # Verify certificate
                  if datetime.utcnow() > cert.not_valid_after or datetime.utcnow() < cert.not_valid_before:
                      raise ValueError("Certificate has expired or is not yet valid")

                  if not check_revocation_status(cert, root_cert):
                      raise ValueError("Certificate has been revoked")

                  expected_uid = get_expected_uid(ENVIRONMENT, DATA_TYPE)
                  
                  if not verify_custom_uid(cert, expected_uid):
                      raise ValueError(f"Certificate does not have the expected UID: {expected_uid}")

                  # Extract the public key
                  public_key = cert.public_key()

                  # Export AES_KEY1 using RSA-OAEP with RSA_KEY1 as the wrapping key
                  enc_aes_key1 = export_aes_key(APC_KEY_ARN, cert_contents, APC_ICA_KEY_ARN)

                  # Prepend the appropriate key block header to ENC_AES_KEY1
                  enc_aes_key1_with_header = prepend_key_block_header(enc_aes_key1, DATA_TYPE)

                  # Sign enc_aes_key1_with_header using RSA_KEY2 in AWS KMS
                  signature = sign_with_kms(enc_aes_key1_with_header, KMS_KEY_ARN)

                  hex_signature = signature.hex()

                  # Prepare the result
                  result = {
                      'APC_ROOT_KEY_ARN': APC_ROOT_KEY_ARN,
                      'KMS_KEY_ARN': KMS_KEY_ARN,
                      'APC_KEY_ARN': APC_KEY_ARN,
                      'enc_aes_key1': enc_aes_key1,
                      'kcv': kcv,
                      'signature': hex_signature
                  }

                  # Optionally store results in S3
                  if S3_BUCKET:
                      s3_locations = store_results_in_s3(result, S3_BUCKET, S3_PREFIX)
                      result['s3_locations'] = s3_locations

                  response_body = {
                      'message': 'All operations completed successfully',
                      'result': result
                  }

                  return {
                      'statusCode': 200,
                      'body': response_body,
                      'headers': {
                          'Content-Type': 'application/json'
                      }
                  }
              except Exception as e:
                  # Get the full traceback
                  tb = traceback.extract_tb(sys.exc_info()[2])
                  # Get the last frame (where the error occurred)
                  last_frame = tb[-1]
                  # Extract the filename, line number, and function name
                  file_name = last_frame.filename
                  line_number = last_frame.lineno
                  func_name = last_frame.name

                  error_message = f"Error in {file_name}, line {line_number}, in {func_name}: {str(e)}"
                  
                  print(error_message)  # Log the error message

                  return {
                      'statusCode': 500,
                      'body': json.dumps({
                          'message': 'Error processing request',
                          'error': error_message,
                          'traceback': traceback.format_exc()  # Include full traceback for more details
                      })
                  }

          def get_key_check_value(key_arn):
              """
              Retrieves the key check value for a given key ARN using AWS Payment Cryptography.

              :param key_arn: The ARN of the key to retrieve the check value for.
              :return: The key check value if successful, None otherwise.
              """
              # Create a boto3 client for the payment-cryptography service
              client = boto3.client('payment-cryptography')

              try:
                  # Call the getKey API
                  response = client.get_key(
                      KeyIdentifier=key_arn
                  )
                  # Extract and return the key check value
                  key_check_value = response['Key']['KeyCheckValue']
                  return key_check_value

              except ClientError as e:
                  print(f"An error occurred: {e}")
                  return None

          def check_revocation_status(cert, root):
              try:
                  aia_extension = cert.extensions.get_extension_for_oid(ExtensionOID.AUTHORITY_INFORMATION_ACCESS)
                  ocsp_server = next((desc.access_location.value for desc in aia_extension.value 
                                      if desc.access_method == x509.oid.AuthorityInformationAccessOID.OCSP), None)
                  
                  if not ocsp_server:
                      print("OCSP server information not found in the certificate")
                      return True  # Or handle this case as appropriate for your use case
              except x509.ExtensionNotFound:
                  print("Authority Information Access extension not found in the certificate")
                  return True  # Or handle this case as appropriate

              print("OCSP Server URL:", ocsp_server)

              root_ca = root

              builder = ocsp.OCSPRequestBuilder()
              builder = builder.add_certificate(cert, root_ca, hashes.SHA256())
              ocsp_request = builder.build()

              try:
                  ocsp_response = requests.post(
                      ocsp_server,
                      data=ocsp_request.public_bytes(serialization.Encoding.DER),
                      headers={'Content-Type': 'application/ocsp-request'},
                      timeout=10
                  )
                  ocsp_response.raise_for_status()
              except requests.RequestException as e:
                  print(f"Error contacting OCSP server: {e}")
                  return True  # Or handle this error as appropriate

              print("OCSP Response Status Code:", ocsp_response.status_code)
              print("OCSP Response Content:", ocsp_response.content[:100])  # Print first 100 bytes

              try:
                  ocsp_response_parsed = ocsp.load_der_ocsp_response(ocsp_response.content)
              except ValueError as e:
                  print(f"Error parsing OCSP response: {e}")
                  return True  # Or handle this error as appropriate

              if ocsp_response_parsed.response_status != ocsp.OCSPResponseStatus.SUCCESSFUL:
                  print(f"OCSP response not successful: {ocsp_response_parsed.response_status}")
                  return True  # Or handle this case as appropriate

              if ocsp_response_parsed.certificate_status == ocsp.OCSPCertStatus.GOOD:
                  return True
              elif ocsp_response_parsed.certificate_status == ocsp.OCSPCertStatus.REVOKED:
                  return False
              else:
                  print(f"Unexpected OCSP status: {ocsp_response_parsed.certificate_status}")
                  return True  # Or handle this case as appropriate

          def get_expected_uid(environment, DATA_TYPE):
              uids = {
                  'non-production': {
                      'cardholder': 'identity:idms.group.9091073',
                      'pin': 'identity:idms.group.9091071'
                  },
                  'production': {
                      'cardholder': 'identity:idms.group.7814046',
                      'pin': 'identity:idms.group.6509948'
                  }
              }
              return uids[environment][DATA_TYPE]

          def verify_custom_uid(cert, expected_uid):
              # Check in Subject field
              for attr in cert.subject:
                  if attr.oid == x509.oid.NameOID.USER_ID:
                      if attr.value == expected_uid:
                          return True
              
              # Check in Subject Alternative Name extension
              try:
                  san_extension = cert.extensions.get_extension_for_oid(ExtensionOID.SUBJECT_ALTERNATIVE_NAME)
                  for name in san_extension.value:
                      if isinstance(name, x509.UniformResourceIdentifier):
                          if expected_uid in name.value:
                              return True
              except x509.ExtensionNotFound:
                  pass

              return False

          def import_public_key_to_payment_crypto(root_cert, ica_cert):
              payment_crypto_client = boto3.client('payment-cryptography')

              try:
                  # Check if root_cert is already a certificate object
                  if isinstance(root_cert, bytes):
                      root_ca = x509.load_pem_x509_certificate(root_cert)
                  else:
                      root_ca = root_cert

                  # Serialize the certificate object to PEM format, encode to base64, and decode to string
                  root_certificate_pem = base64.b64encode(root_ca.public_bytes(encoding=serialization.Encoding.PEM)).decode('utf-8')
                  
                  response = payment_crypto_client.import_key(
                      KeyMaterial={
                          'RootCertificatePublicKey': {
                              'KeyAttributes': {
                                  "KeyUsage": "TR31_S0_ASYMMETRIC_KEY_FOR_DIGITAL_SIGNATURE",
                                  "KeyClass": "PUBLIC_KEY",
                                  "KeyAlgorithm": "RSA_4096",
                                  "KeyModesOfUse": {
                                      "Verify": True
                                  }
                              },
                              'PublicKeyCertificate': root_certificate_pem,
                          }
                      },
                      KeyCheckValueAlgorithm='CMAC',
                      Enabled=True,
                      Tags=[
                          {
                              'Key': 'Name',
                              'Value': 'IMPORTED_ROOT_CA_CERT'
                          },
                          {
                              'Key': 'Description',
                              'Value': 'Imported Root certificate public key'
                          }
                      ]
                  )

                  rootARN = response['Key']['KeyArn']

                  # Check if ica_cert is already a certificate object
                  if isinstance(ica_cert, bytes):
                      ica_ca = x509.load_pem_x509_certificate(ica_cert)
                  else:
                      ica_ca = ica_cert

                  # Serialize the certificate object to PEM format, encode to base64, and decode to string
                  ica_certificate_pem = base64.b64encode(ica_ca.public_bytes(encoding=serialization.Encoding.PEM)).decode('utf-8')

                  response = payment_crypto_client.import_key(
                      KeyMaterial={
                          'TrustedCertificatePublicKey': {
                              'CertificateAuthorityPublicKeyIdentifier': rootARN,
                              'KeyAttributes': {
                                  "KeyUsage": "TR31_S0_ASYMMETRIC_KEY_FOR_DIGITAL_SIGNATURE",
                                  "KeyClass": "PUBLIC_KEY",
                                  "KeyAlgorithm": "RSA_4096",
                                  "KeyModesOfUse": {
                                      "Verify": True
                                  }
                              },
                              'PublicKeyCertificate': ica_certificate_pem,
                          }
                      },
                      KeyCheckValueAlgorithm='CMAC',
                      Enabled=True,
                      Tags=[
                          {
                              'Key': 'Name',
                              'Value': 'IMPORTED_ICA_CERT'
                          },
                          {
                              'Key': 'Description',
                              'Value': 'Imported public key from intermediate CA certificate'
                          }
                      ]
                  )

                  intermediateARN = response['Key']['KeyArn']

                  return rootARN, intermediateARN

              except ClientError as e:
                  error_code = e.response['Error']['Code']
                  error_message = e.response['Error']['Message']
                  print(f"Error importing public key: {error_code} - {error_message}")
                  raise
              except Exception as e:
                  print(f"Unexpected error: {str(e)}")
                  raise e

          def generate_rsa_key_pair_in_kms():
              kms_client = boto3.client('kms')
              
              response = kms_client.create_key(
                  Description='RSA_KEY2 for signing',
                  KeyUsage='SIGN_VERIFY',
                  KeySpec='RSA_2048',
                  MultiRegion=False
              )
              
              return response['KeyMetadata']['Arn']

          class KMSPrivateKey:
              def __init__(self, key_id):
                  self.key_id = key_id
                  self.client = boto3.client('kms')

              def sign(self, data, padding, algorithm):
                  if not isinstance(algorithm, hashes.SHA256):
                      raise ValueError("Only SHA256 is supported")

                  response = self.client.sign(
                      KeyId=self.key_id,
                      Message=data,
                      MessageType='DIGEST',
                      SigningAlgorithm='RSASSA_PKCS1_V1_5_SHA_256'
                  )

                  return response['Signature']

              def public_key(self):
                  response = self.client.get_public_key(KeyId=self.key_id)
                  return serialization.load_der_public_key(response['PublicKey'])

          def generate_aes_128_key():
              payment_crypto_client = boto3.client('payment-cryptography')

              response = payment_crypto_client.create_key(
                  KeyAttributes={
                      "KeyUsage": "TR31_K0_KEY_ENCRYPTION_KEY",
                      "KeyClass": "SYMMETRIC_KEY",
                      "KeyAlgorithm": "AES_128",
                      "KeyModesOfUse": {
                          "Encrypt": True,
                          "Decrypt": True,
                          "Wrap": True,
                          "Unwrap": True,
                          "Generate": False,
                          "Sign": False,
                          "Verify": False,
                          "DeriveKey": False,
                          "NoRestrictions": False
                      }
                  },
                  KeyCheckValueAlgorithm='CMAC',
                  Exportable=True,
                  Enabled=True,
                  Tags=[
                      {
                          'Key': 'Name',
                          'Value': 'AES128_PSP_KEK'
                      },
                      {
                          'Key': 'Description',
                          'Value': 'AES 128 Key for encryption and key wrapping'
                      }
                  ]
              )

              # Extract the correct fields from the response
              key_arn = response['Key']['KeyArn']
              key_check_value = response['Key']['KeyCheckValue']

              return key_arn, key_check_value

          def export_aes_key(aes_key_arn, certificate_pem, ICA_ROOT_KEY_ARN):
              payment_crypto_client = boto3.client('payment-cryptography')

              certificate_body = base64.b64encode(certificate_pem).decode('utf-8')

              response = payment_crypto_client.export_key(
                  KeyMaterial={
                      'KeyCryptogram': {
                          'CertificateAuthorityPublicKeyIdentifier': ICA_ROOT_KEY_ARN,
                          'WrappingKeyCertificate': certificate_body,
                          'WrappingSpec': 'RSA_OAEP_SHA_256'
                      }
                  },
                  ExportKeyIdentifier=aes_key_arn
              )

              return response['WrappedKey']['KeyMaterial']

          def prepend_key_block_header(enc_aes_key, DATA_TYPE):
              if DATA_TYPE == 'cardholder':
                  header = '3130303030545041454159'
              elif DATA_TYPE == 'pin':
                  header = '3130303030545041454959'
              else:
                  raise ValueError(f"Invalid DATA_TYPE: {DATA_TYPE}. Expected 'cardholder' or 'pin'.")
              
              return header + enc_aes_key

          def sign_with_kms(data_to_sign, key_arn):
              kms_client = boto3.client('kms')
              message_bytes = bytes.fromhex(data_to_sign)
              
              response = kms_client.sign(
                  KeyId=key_arn,
                  Message=message_bytes,
                  MessageType='RAW',
                  SigningAlgorithm='RSASSA_PKCS1_V1_5_SHA_256'
              )

              return response['Signature']

          def store_results_in_s3(result, bucket, prefix):
              s3_client = boto3.client('s3')
              s3_locations = {}

              # Combine the three key ARNs into one file
              key_arns = [
                  f"KMS Key ARN: {result['KMS_KEY_ARN']}",
                  f"APC Root Key ARN: {result['APC_ROOT_KEY_ARN']}",
                  f"APC Key ARN: {result['APC_KEY_ARN']}"
              ]
              key_arns_content = "\n".join(key_arns)

              file_key = f"{prefix}KEY_ARNS.txt"
              try:
                  s3_client.put_object(
                      Bucket=bucket,
                      Key=file_key,
                      Body=key_arns_content.encode('utf-8')
                  )
                  s3_locations['KEY_ARNS'] = f"s3://{bucket}/{file_key}"
              except ClientError as e:
                  print(f"Error storing KEY_ARNS in S3: {e}")
                  raise

              # Store the remaining files
              for key, value in result.items():
                  if key in ['KMS_KEY_ARN', 'APC_ROOT_KEY_ARN', 'APC_KEY_ARN']:
                      # Skip these keys as they are already combined
                      continue

                  if value is None:
                      print(f"Skipping storing {key} in S3 as the value is None.")
                      continue

                  if key in ['enc_aes_key1', 'kcv']:
                      # These are already in hex format, store as is
                      content = str(value)
                  elif key == 'signature':
                      content = value if isinstance(value, str) else base64.b64encode(value).decode('utf-8')
                  else:
                      # For other values, assume they're base64 encoded
                      try:
                          content = base64.b64decode(value).hex()
                      except:
                          content = str(value)

                  file_key = f"{prefix}{key}.txt"
                  try:
                      s3_client.put_object(
                          Bucket=bucket,
                          Key=file_key,
                          Body=content.encode('utf-8')
                      )
                      s3_locations[key] = f"s3://{bucket}/{file_key}"
                  except ClientError as e:
                      print(f"Error storing {key} in S3: {e}")
                      raise

              return s3_locations


      Environment:
        Variables:
          CERTIFICATE_S3_URI: !Ref CertificateS3URI
          ROOT_CERTIFICATE_S3_URI: !Ref RootCertificateS3URI
          ICA_CERTIFICATE_S3_URI: !Ref ICACertificateS3URI
          DATA_TYPE: !Ref DataType
          ENVIRONMENT: !Ref Environment
          KMS_KEY_ARN: !GetAtt CSRKMSKey.Arn
          APC_KEY_ARN: !Ref APCKeyARN
          APC_ROOT_KEY_ARN: !Ref APCRootKeyARN
          APC_ICA_KEY_ARN: !Ref APCICAKeyARN
          S3_BUCKET: !Ref ResultsBucket
      MemorySize: 128
      Role: !GetAtt PspKEKexchangeRole.Arn
      Runtime: "python3.11"
      Timeout: 30
      EphemeralStorage: 
        Size: 512
      Layers: 
        - !Sub "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:layer:cryptography-layer:1"

Outputs:
  ResultsBucket:
    Description: "S3 Bucket containing keys generated"
    Value: !Ref ResultsBucket