# python3 -m pip install requests
# python3 -m pip install pycryptodome

import re
import time
import json
import base64
import socket
import secrets
import logging
import helpers.atalla_helper as atalla_helper
import helpers.csr_helper as csr_helper
from typing import Tuple

from Crypto.Hash import SHA256
from Crypto.PublicKey.RSA import construct
from oscrypto import asymmetric
import helpers.aws_private_ca_helper as private_ca_helper
import helpers.apc_helper as apc_helper


from cryptography import x509
from cryptography.hazmat.primitives import serialization
import argparse
import base64

###########################################################
# README
###########################################################
# This will require some setup.
# 1. Call GetParametersForImport. Save the output under keys/params_for_import.json
# 2. Import the KRD CA certificate (leaf public key cert) from the WrappingKeyCertificate of keys/params_for_import.json into Atalla.
# The KRD (in this case APC) public key akb is generated outside of this script and requires a manual process.

# Steps - 
# a. Get the modulus of the public key cert. Example - echo "WrappingKeyCertificate data" | base64 -d | openssl x509 -modulus -noout
# b. In Atalla, the krd public key akb is generated by command 12A - which is a 2 step command that requires dual control.
# The first step is <12A#1kREE000#010001#modulus##> which returns a security challenge. The 12A command is rerun after the
# security challenge is completed via admin screen on Atalla. Secnad command will be something like -
# <12A#1kREE000#010001#modulus#security channelge answer#>. The output of the second command gives the public key akb
# and will look something like <22A#OK#1kREE000,00030100010100B0357EB48EEEEAE......#>
# c. Save output from the header onwards to the end of the response on to the krd_public_key_akb file, which for this sample
# is in keys/tr34_offline_krd_public_key_akb file.
#
# Usage - Example: python3 atalla_to_apc_tr34.py '127.0.0.1' 7000

# TR-31 Version B
# K0 - KEK, K1 - Key block proteciton key (such as for command 119)
KEY_HEADER = 'B9999K1TB00E0000'

OID_MGF1 = bytes.fromhex('2A864886F70D010108')
OID_SHA256 = bytes.fromhex('608648016503040201')

OID_DES_EDE3_CBC =   bytes.fromhex('2A864886F70D0307')

OID_ENCRYPTION = OID_DES_EDE3_CBC
BLOCK_SIZE = 8

OID_PKCS7_DATA = bytes.fromhex('2A864886F70D010701')
OID_RSAES_OEAP = bytes.fromhex('2A864886F70D010107')
OID_P_SPECIFIED = bytes.fromhex('2A864886F70D010109')
OID_CONTENT_TYPE = bytes.fromhex('2A864886F70D010903')
OID_SIGNING_TIME = bytes.fromhex('2A864886F70D010905')
OID_MESSAGE_DIGEST = bytes.fromhex('2A864886F70D010904')
OID_RSA_ENCRYPTION = bytes.fromhex('2A864886F70D010101')
OID_PKCS7_SIGNED_DATA = bytes.fromhex('2A864886F70D010702')
OID_PKCS7_ENVELOPED_DATA = bytes.fromhex('2A864886F70D010703')
OID_PKCS_9_AT_RANDOM_NONCE = bytes.fromhex('2A864886F70D01091903')
OID_SHA256_WITH_RSA_ENCRYPTION = bytes.fromhex('2A864886F70D01010B')

KDH_CA_KEY_ALIAS = 'alias/tr34-key-import-kdh-ca'
IMPORT_KEY_ALIAS = 'alias/tr34-key-import'

#logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

###########################################################
# Some ASN1 Stuff
###########################################################

def parse_asn_header(data: bytes, offset=0):
    if len(data) < 2 + offset:
        raise Exception('Header too short')

    tag = data[offset]
    constructed = tag & 0x20 != 0

    length = int.from_bytes(data[offset + 1:offset + 2], 'big')
    length_of_length = length & 0x7F
    if length & 0x80 and len(data) < 2 + offset + length_of_length:
        raise Exception('Payload is too short to extract length at offset ' + str(offset))
    elif length & 0x80:
        length = int.from_bytes(data[offset + 2:offset + 2 + length_of_length], 'big')
    else:
        length_of_length = 0
    if len(data) < 2 + offset + length_of_length + length:
        raise Exception('Payload is too short at offset ' + str(offset))
    payload_offset = offset + 2 + length_of_length

    return (tag, constructed, payload_offset, length, 2 + length_of_length + length)

def parse_asn(data: bytes, offset=0, limit=-1):
    items = []

    if len(data) == 0 or limit >= 0 and offset >= limit:
        return items

    current_limit = limit
    if current_limit < 0:
        current_limit = len(data)
    current_offset = offset

    while current_offset < current_limit:
        (tag, constructed, payload_offset, payload_length, total_length) = parse_asn_header(data, current_offset)
        if not constructed:
            items.append((tag, False, data[payload_offset:payload_offset + payload_length]))
        else:
            items.append((tag, True, parse_asn(data, payload_offset, payload_offset + payload_length)))
        current_offset += total_length
    return items

def encode_asn(asn_data):
    buffer = b''

    for value in asn_data:
        child_data = value[2]
        if value[1]:
            child_data = encode_asn(value[2])

        buffer += value[0].to_bytes(1, 'big')
        length = len(child_data)
        if length > 0x7F:
            field_length = ((length.bit_length() + 7) // 8)
            buffer += (field_length | 0x80).to_bytes(1, 'big')
            buffer += length.to_bytes(field_length, 'big')
        else:
            buffer += length.to_bytes(1, 'big')
        buffer += child_data
    return buffer

###########################################################
# Some TCP Stuff
###########################################################
def send_data(target: Tuple[str, int], data: bytes, pattern: str, terminator: bytes = b''):

    s = socket.create_connection(target, timeout=10)
    s.settimeout(30)
    s.sendall(data)

    end_time = time.time() + 30

    output = b''
    while end_time > time.time():
        try:
            output += s.recv(2**16)
            if terminator and terminator in output:
                break
        except socket.timeout:
            break

    matcher = re.match(pattern, output.decode())
    if not matcher:
        raise Exception('Failed to parse data ' + output.decode() + ' for command ' + data.decode())
    return matcher.groups()

def runProgram(wrappedKeyToExport,atalla_address,mode):

    ###########################################################
    # Load KRD Certificates
    ###########################################################

    with open(params_for_import_file, 'rb') as f:
        params_for_import = json.load(f)
    krd_certificate = x509.load_pem_x509_certificate(base64.b64decode(params_for_import['WrappingKeyCertificate']))
    import_token = params_for_import['ImportToken']    
    
    with open(krd_public_key_akb, 'r') as f:
        krd_public_key_block = f.read()

    ###########################################################
    # Load KDH Certificates
    ###########################################################

    pub_key_atalla, priv_key_atalla = atalla_helper.createRsaKey(atalla_address)

    print("Building CSR")
    builder = csr_helper.AtallaCSRBuilder(
        {
            'country_name': 'USA',
            'state_or_province_name': 'California',
            'locality_name': 'San Francisco',
            'organization_name': 'AWS Samples',
            'common_name': 'AWS Payment Cryptography Test',
        }
    )
    
    pubKey_modulus = pub_key_atalla.split(",")[1][14:] #a bit of a hack - the format is length(2 bytes), exponent, length(2 bytes), modulus but we are always using 512(256 bytes or 2048 bits)
    e = int('10001', 16)
    n = int(pubKey_modulus, 16)  #snipped for brevity
    pubkey = construct((n, e))
    derKey = pubkey.exportKey(format='DER')
    pubKeyObject = asymmetric.load_public_key(derKey)

    csr_request = builder.build_csr(priv_key_atalla,pubKeyObject,atalla_address)

    print("PCA - Issuing certificate")
    kdh_certificate_pem, kdh_certificate_chain_pem = private_ca_helper.issue_certificate(csr_content=csr_request)

    kdh_certificate = x509.load_pem_x509_certificate(kdh_certificate_pem.encode('ascii'))
    #kdh_cert_der = kdh_certificate.public_bytes(encoding=serialization.Encoding.DER)

    ###########################################################
    # Generate a Nonce
    ###########################################################

    tr34_2pass_nonce = secrets.token_bytes(8)

    ###########################################################
    # Calculate TR-34 Identities
    ###########################################################

    krd_certificate_asn = parse_asn(krd_certificate.public_bytes(serialization.Encoding.DER))
    krd_certificate_serial_number_asn = krd_certificate_asn[0][2][0][2][1]
    krd_certificate_issuer_asn = krd_certificate_asn[0][2][0][2][3]
    krd_certificate_id_asn = (0x30, True, [krd_certificate_issuer_asn, krd_certificate_serial_number_asn])

    kdh_certificate_asn = parse_asn(kdh_certificate.public_bytes(serialization.Encoding.DER))
    kdh_certificate_serial_number_asn = kdh_certificate_asn[0][2][0][2][1]
    kdh_certificate_issuer_asn = kdh_certificate_asn[0][2][0][2][3]
    kdh_certificate_id_asn = (0x30, True, [kdh_certificate_issuer_asn, kdh_certificate_serial_number_asn])

    ############################################################
    # Generate the Encrypted Ephemeral Key Block
    ############################################################

    be_data = encode_asn([
        (0x02, False, bytes.fromhex('01')),
        kdh_certificate_id_asn,
    ]).hex().upper()

    #Generate a TR-34 Key Block.  You want to save the output key so that you can subsequentially use it in 11A command to wrap other keys
    tr34_envelope_data = send_data(atalla_address, ('<136#T#%s##%s#D#4#%s#>' % (KEY_HEADER, be_data, krd_public_key_block)).encode(), '<236#(.*?)#(.*?)#(.*?)#(.*?)#(.*?)#(.*?)#.*>', b'>')

    symmetric_key_block = tr34_envelope_data[0]
    symmetric_key_kcv = tr34_envelope_data[1]
    encrypted_ephemeral_key = bytes.fromhex(tr34_envelope_data[2])
    key_block_iv = bytes.fromhex(tr34_envelope_data[3])
    encrypted_key_block = bytes.fromhex(tr34_envelope_data[4])
    signing_token = tr34_envelope_data[5]

    ###########################################################
    # Build TR-34 Key Block Envelope
    ###########################################################

    tr34_key_block_envelope = encode_asn([
        (0x02, False, bytes.fromhex('00')),
        (0x31, True, [
            (0x30, True, [
                (0x02, False, bytes.fromhex('00')),
                krd_certificate_id_asn,
                (0x30, True, [
                    (0x06, False, OID_RSAES_OEAP),
                    (0x30, True, [
                        (0x30, True, [
                            (0x06, False, OID_SHA256),
                            (0x05, False, b'')
                        ]),
                        (0x30, True, [
                            (0x06, False, OID_MGF1),
                            (0x30, True, [
                                (0x06, False, OID_SHA256)
                            ])
                        ]),
                        (0x30, True, [
                            (0x06, False, OID_P_SPECIFIED),
                            (0x04, False, b'')
                        ])
                    ])
                ]),
                (0x04, False, encrypted_ephemeral_key)
            ])
        ]),
        (0x30, True, [
            (0x06, False, OID_PKCS7_DATA),
            (0x30, True, [
                (0x06, False, OID_ENCRYPTION),
                (0x04, False, key_block_iv),
                (0x80, False, encrypted_key_block)
            ])
        ])
    ])

    ###########################################################
    # Calculate TR-34 Envelope Data Checksum
    ###########################################################

    tr34_envelope_digest = SHA256.new(tr34_key_block_envelope).digest()

    ###########################################################
    # Generate the TR-34 Authentication Data
    ###########################################################

    tr34_authentication_data_asn = [
        (0x30, True, [
            (0x06, False, OID_CONTENT_TYPE),
            (0x31, True, [
                (0x06, False, OID_PKCS7_ENVELOPED_DATA)
            ])
        ]),
        # (0x30, True, [
        #     (0x06, False, OID_SIGNING_TIME),
        #     (0x31, True, [
        #         (0x17, False, b'230620131924Z')
        #     ])
        # ]),
        (0x30, True, [
            (0x06, False, OID_PKCS_9_AT_RANDOM_NONCE),
            (0x31, True, [
                (0x04, False, tr34_2pass_nonce)
            ])
        ]),
        (0x30, True, [
            (0x06, False, OID_PKCS7_DATA),
            (0x31, True, [
                (0x04, False, KEY_HEADER.encode())
            ])
        ]),
        (0x30, True, [
            (0x06, False, OID_MESSAGE_DIGEST),
            (0x31, True, [
                (0x04, False, tr34_envelope_digest)
            ])
        ])
    ]

    ###########################################################
    # Generate the TR-34 Authentication Data Signature
    ###########################################################

    tr34_kdh_signed_data = encode_asn([(0x31, True, tr34_authentication_data_asn)])

    # TODO: Consider parsing the message as opposed to using find as done below
    ephemeral_key_offset = tr34_key_block_envelope.hex().find(encrypted_ephemeral_key.hex()) + 1
    key_block_iv_offset = tr34_key_block_envelope.hex().find(key_block_iv.hex()) + 1
    be_offset = tr34_key_block_envelope.hex().find(encrypted_key_block.hex()) + 1
    #139 - Sign TR-34 Message
    tr34_authentication_data_signature = bytes.fromhex(send_data(atalla_address, ('<139#5#1#%s#%s#0%s#%s#%s#%s#%s#>' % (tr34_kdh_signed_data.hex().upper(), tr34_key_block_envelope.hex().upper(), ephemeral_key_offset, key_block_iv_offset, be_offset, signing_token, priv_key_atalla)).encode(), '<239#.*?#(.*?)#.*>', b'>')[0])

    ###########################################################
    # Build the full TR-34 payload
    ###########################################################

    tr34_payload = encode_asn([
        (0x30, True, [
            (0x06, False, OID_PKCS7_SIGNED_DATA),
            (0xA0, True, [
                (0x30, True, [
                    (0x02, False, bytes.fromhex('01')),
                    (0x31, True, [
                        (0x30, True, [
                            (0x06, False, OID_SHA256)
                        ])
                    ]),
                    (0x30, True, [
                        (0x06, False, OID_PKCS7_ENVELOPED_DATA),
                        (0xA0, True, [
                            (0x04, False, tr34_key_block_envelope)
                        ])
                    ]),
                    (0x31, True, [
                        (0x30, True, [
                            (0x02, False, bytes.fromhex('01')),
                            kdh_certificate_id_asn,
                            (0x30, True, [
                                (0x06, False, OID_SHA256)
                            ]),
                            (0xA0, True, tr34_authentication_data_asn),
                            (0x30, True, [
                                (0x06, False, OID_RSA_ENCRYPTION),
                                (0x05, False, b'')
                            ]),
                            (0x04, False, tr34_authentication_data_signature)
                        ])
                    ])
                ])
            ])
        ])
    ])


    ###########################################################
    # Record the output
    ###########################################################

    print('Nonce: ' + tr34_2pass_nonce.hex().upper())
    print('Random KEK wrapped under MFK:',symmetric_key_block)
    print('Random KEK\'s KCV.  This will match once imported into APC:', symmetric_key_kcv)
    kdh_ca_key_arn = apc_helper.importPublicCACertificate(kdh_certificate_chain_pem)
    try:
        apc_helper.importTR34Payload(tr34_payload.hex().upper(),tr34_2pass_nonce.hex().upper(),kdh_ca_key_arn,kdh_certificate_pem,import_token)
    except Exception as e:
        apc_helper.deleteKeyIfExixts(kdh_ca_key_arn)
        logger.error("Failed to delete key: %s", str(e), exc_info=True)

if __name__ == "__main__":

    print('###############################################################################')
    print ("Sample code to export a key from Atalla HSM and import into AWS Payment Cryptography using TR-34")
    print ("Note that requires that the KRD CA is installed separately.  If a KEK has already been shared, TR-31 is recommended.")
    print ("This is currently intended for 3DES keys.")
    print ("This code is sample only and comes with no warranty")
    print('###############################################################################')

    parser = argparse.ArgumentParser(prog='TR-34 Atalla/Uimaco Export following AWS Payment Cryptography Key Import Concepts',
                                     description='Sample code to generate a TR-34 2012 non-CMS format from Utimaco AT1000 in the format required for AWS Payment Cryptography. \
                    The code will either generate a brand new KEK or will export a key if specified on the command line.',
                                     epilog='This is intended as sample code and comes with no waranty and is not intended for us with production keys.')
    parser.add_argument("--wrappedKey", help="Wrapped Key to export from Atalla", default="")
    parser.add_argument("--host", help="Atalla Host", default="localhost")
    parser.add_argument("--port", help="Atalla Port", default=7000,type=int)
    parser.add_argument("--krd_public_key_akb_file", help="File containing KRD Public Key in AKB format", default="keys/tr34_offline_krd_public_key_akb")
    parser.add_argument("--params_for_import_file", help="File containing parameters from import for APC which has WrappingKeyCertificate that will be loaded as KRD(leaf) certificate for TR34 payload generation.", default="keys/params_for_import.json")
    
    args = parser.parse_args()

    krd_public_key_akb = args.krd_public_key_akb_file
    params_for_import_file = args.params_for_import_file

    print("KDH Public Key AKB:  ", '%s' % krd_public_key_akb)
    print("Get Parameters for Import : ", '%s' % params_for_import_file)


    runProgram(args.wrappedKey, (args.host, args.port),'OFFLINE')